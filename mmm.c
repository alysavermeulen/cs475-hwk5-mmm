#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"

int size;
double **m1;
double **m2;
double **output;

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random integers from 0 to 99
 * @param s The size of the matrices
 */
void mmm_init(int s)
{
	size = s;
	int i, j;
	m1 = (double **)malloc(size * sizeof(double *)); // allocate first input matrix
	m2 = (double **)malloc(size * sizeof(double *)); // allocate second input matrix
	output = (double **)malloc(size * sizeof(double *)); // allocate output matrix
	for (i = 0; i < size; i++){ // dynamically allocate memory for each row in matrices
        m1[i] = (double *)malloc(size * sizeof(double));
		m2[i] = (double *)malloc(size * sizeof(double));
		output[i] = (double *)malloc(size * sizeof(double));
    }

	for (i = 0; i < size; i++){ // initialize input matrices with random integers
        for (j = 0; j < size; j++){
            m1[i][j] = rand() % 100;
			m2[i][j] = rand() % 100;
        }
    }
}

/**
 * Reset a given matrix to zeroes
 * @param matrix The matrix to be reset
 */
void mmm_reset(double **matrix)
{
	int i, j;
	for (i = 0; i < size; i++){
        for (j = 0; j < size; j++){
            matrix[i][j] = 0;
        }
    }
}

/**
 * Free up memory allocated to all matrices
 */
void mmm_freeup()
{
	int i;
	for (i = 0; i < size; i++){
        free(m1[i]);
		free(m2[i]);
		free(output[i]);
    }
    free(m1);
    free(m2);
    free(output);
}

/**
 * Sequential MMM
 */
void mmm_seq()
{
	double sum = 0;
	int i, j, k;
	for (i = 0; i < size; i++){
        for (j = 0; j < size; j++){
			for (k = 0; k < size; k++){
				sum += m1[i][k] * m2[k][j];
			}
			output[i][j] = sum;
			sum = 0;
        }
    }
}

/**
 * Parallel MMM
 * @param args A pointer to a thread_args struct
 */
void *mmm_par(void *args)
{
	// cast input as struct thread_args
  	thread_args *params = (thread_args *)args;
	double sum = 0;
	int i, j, k;
	for (i = params->begin; i <= params->end; i++){
        for (j = 0; j < size; j++){
			for (k = 0; k < size; k++){
				sum += m1[i][k] * m2[k][j];
			}
			output[i][j] = sum;
			sum = 0;
        }
    }
	return NULL;
}

/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 * @param output1 The matrix generated by the sequential run
 * @param output2 The matrix generated by the parallel run
 * @return the largest error between two corresponding elements
 */
double mmm_verify(double **output1, double **output2)
{
	double diff = 0; // largest error between two corresponding elements
	int i, j;
	for (i = 0; i < size; i++){
        for (j = 0; j < size; j++){
            if (fabs(output1[i][j] - output2[i][j]) > diff){
				diff = fabs(output1[i][j] - output2[i][j]);
			}
        }
    }
	return diff;
}
